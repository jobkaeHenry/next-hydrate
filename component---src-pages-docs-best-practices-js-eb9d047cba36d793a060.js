"use strict";(self.webpackChunk_jobkaehenry_next_hydrate_docs=self.webpackChunk_jobkaehenry_next_hydrate_docs||[]).push([[662],{5301:function(e,t,n){n.r(t);var l=n(758),r=n(2557),a=n(3912),c=n(1145);t.default=()=>l.createElement(l.Fragment,null,l.createElement(c.A,{title:"Best Practices - next-hydrate",description:"Best practices for using next-hydrate effectively in production applications",pathname:"/docs/best-practices"}),l.createElement(r.A,null,l.createElement("h1",null,"Best Practices"),l.createElement("h2",null,"General Guidelines"),l.createElement("h3",null,"1. Choose the Right Fetch Mode"),l.createElement("p",null,"Select the appropriate rendering strategy for your use case:"),l.createElement("ul",null,l.createElement("li",null,l.createElement("strong",null,"SSG")," for static content"),l.createElement("li",null,l.createElement("strong",null,"ISR")," for periodic updates"),l.createElement("li",null,l.createElement("strong",null,"SSR")," for dynamic user data"),l.createElement("li",null,l.createElement("strong",null,"CSR")," for client-only data")),l.createElement("h3",null,"2. Optimize Payload Size"),l.createElement("p",null,"Keep hydration payloads small for better performance:"),l.createElement(a.A,{code:"// âœ“ Good: Paginated data\nconst props = await getHydrationProps({\n  queryClient,\n  queries: [\n    {\n      queryKey: ['products', { page: 1, limit: 20 }],\n      queryFn: () => fetchProducts({ page: 1, limit: 20 }), // ~50KB\n    },\n  ],\n})",language:"typescript"}),l.createElement("h3",null,"3. Use Proper Query Keys"),l.createElement("p",null,"Structure query keys for effective caching using hierarchical, descriptive keys."),l.createElement("h2",null,"Performance Optimization"),l.createElement("h3",null,"1. Implement Stale Time"),l.createElement("p",null,"Prevent unnecessary refetching by setting appropriate staleTime (e.g., 5 minutes)."),l.createElement("h3",null,"2. Use Query Prefetching"),l.createElement("p",null,"Prefetch data on server for better UX."),l.createElement("h3",null,"3. Implement Concurrency Control"),l.createElement("p",null,"Avoid overwhelming the server - batch or limit concurrent requests."),l.createElement("h2",null,"Type Safety"),l.createElement("h3",null,"Define Query Types"),l.createElement("p",null,"Use TypeScript for type-safe queries:"),l.createElement(a.A,{code:"interface Post {\n  id: string\n  title: string\n  content: string\n}\n\nconst props = await getHydrationProps({\n  queryClient,\n  queries: [\n    {\n      queryKey: ['posts'],\n      queryFn: async (): Promise<Post[]> => {\n        const res = await fetch('/api/posts')\n        return res.json()\n      },\n    },\n  ],\n})",language:"typescript"}),l.createElement("h2",null,"Security"),l.createElement("h3",null,"1. Sanitize Data"),l.createElement("p",null,"Always sanitize data before hydration to prevent XSS attacks."),l.createElement("h3",null,"2. Validate Data"),l.createElement("p",null,"Validate server responses using schema validation (e.g., Zod)."),l.createElement("h3",null,"3. Protect Sensitive Data"),l.createElement("p",null,"Never hydrate sensitive information like passwords, tokens, etc."),l.createElement("h2",null,"Next Steps"),l.createElement("ul",null,l.createElement("li",null,"Review ",l.createElement("a",{href:"/docs/troubleshooting"},"Troubleshooting")," for common issues"),l.createElement("li",null,"Check ",l.createElement("a",{href:"/docs/api"},"API Reference")," for detailed documentation"),l.createElement("li",null,"Explore ",l.createElement("a",{href:"/docs/examples"},"Examples")," for real-world usage"))))}}]);
//# sourceMappingURL=component---src-pages-docs-best-practices-js-eb9d047cba36d793a060.js.map